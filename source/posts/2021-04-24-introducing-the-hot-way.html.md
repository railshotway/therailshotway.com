---
title: 'The Value of Code'
date: 2021-04-24 19:44 UTC
author: avi_flombaum
tags:
  - history
  - values
  - philosophy
published: false
---

## Welcome to the World Wide Web

In 1989 Sir Tim Berners-Lee began working on a set of technologies that came together to become what is today known as The Web and even the Internet. What the Web is at is essence is a global, decentralized, application architecture allowing any computer connected to the internet to serve an application in the form of HTML documents and client-side code over HTTP/S rendered by browsers, which today are powerful graphical and interpreter engines. The Web thus represents the most ubiquitous and robust software platform in history. What started as simple HTML documents that could hyperlink to other HTML documents, thereby weaving the web together, now delivers the biggest networked applications in history. Trillions of dollars of value have been created by these applications and endless amounts of social good has been accomplished. The Web has done nothing short of change the world and humanity forever.
  
## First Principle: Make Meaning

Programming is the art and science of giving computers instructions. As computers, the internet, and the Web have matured, the type of applications built have grown in complexity. To solve for this, programmers have created a plethora of incredibly helpful languages, libraries, and patterns. To make the development of software easier is to unleash the creativity of millions and allow individuals, communities, and companies to manifest their dreams and ambitions through their code.

> “How do we convince people that in programming simplicity and clarity – in short: what mathematicians call elegance – are not a dispensable luxury, but a crucial matter that decides between success and failure?” Edgar Dijkstra
 
The craft of code can be incredibly engaging. Those moments of frustration, followed by the catharsis of solution, the epiphanies of understanding, the marvel at a beautiful implementation pattern, what mathematicians call elegance, and the profound flow states reached, make writing code an intoxicating experience. So much so that software developers can engage in some of the most heated, antagonistic, and caustic battles on the internet over both important and trivial aspects of code.

While everyone is free to have their individual preferences on what is best, I have always reached for a first principle when thinking about how I write code and how I review the code of my students and team. My first principle is to evaluate code on what I feel is the most important, the most central tenet of the craft, which is paradoxically not the code at all, but the value of the end product. The product I am building is more important to me than how I build it. I care about my code, about languages, frameworks, patterns, and workflows only to the extent that they can help me deliver and ship software reliably. 

If the value in code is rooted in the value of software, code is meaningful because the software we create with it is is meaningful. After 20 years as a software developer, 15 years of managing hundreds of developers on my teams, 10 years teaching over 5,000 how to code and getting them jobs, I believe the following 2nd order value most serves creating meaning with code. 

## Second Order: Speed is Everything

Speed is everything. The faster you can implement an idea, the quicker you can iterate, the more iterations, the better the result. Every great person I know in any field is an expert in being fast. There is no talent, there are only people that have failed a lot, kept trying, got feedback, made improvements, gained experience, and after years of this, found success. It's simple. If you can try more approaches, an order of magnitude more, in the same time someone else can try one, you are more likely to land on the best one.

I remember watching one of the most talented product designers in the world use Photoshop fifteen years ago. At that point I too fancied myself an adequate designer but always found my time in Photoshop cumbersome. I lacked a fluidity with the tool and my designs took me time to make and my organization of the UI elements made making updates hard. Eventually, I would just stop designing in Photoshop and rely on my ability to design directly in code. As fluent as I was in HTML and CSS, I could never really easily play with different aesthetics and would rely on low-fidelity wireframes and sketches to iterate with and then move into code. I always knew that this was holding me and the value of my software back and have been luckily enough to work with some incredibly professional and fast designers. But watching my friend use Photoshop when he was just 22, he was as fluid and smooth with it as I was in my code editor and terminal. Moving between layers, making global edits to design elements and themes, and trying different concepts with the smoothness and speed of water flowing unincumbered down a river. He wasn't famous or rich then, but I knew watching how he worked that he would make and design some of the most important and innovative products in the future.

To speed there is the speed of development, impacted by the ease of the tools you choose to solve the problems presented by your application. Additionally, there is the speed of the system itself as different languages and frameworks have different implications to how fast your software can be delivered. Finally, there is the speed of your team, how fast are they in these tools, how quickly can they learn and adopt best practices, and how well the ecosystem supports painless collaboration.

I choose the tools and patterns that most directly impact speed because speed will most directly contribute to my code's value creation, and that is what really matters. I don't care about using the fancy new library. I don't care about needless migrations to newer framework versions just because. I don't care about using the fastest language if a language more suited for the problem domain is fast enough to the end user. I don't care about being cool, trendy, or fancy. I just want me and my team to be fast because that is what signals to me that we are focused on the what's actually important - making great products.

## Third Factors

The values I have found that most impact the speed of my software development, my teams contributions, and the response of the application are, in no particular order:

- Stability
- Maintainability
- Extensibility
- Compatibility
- Ubiquity
- Interoperability
- Simplicity

### Stability

Stability in software is the integrity of the system. How often are bugs or regressions introduced? How often does the system crash? How often is an issue mysteriously here today but gone tomorrow? How reliably and timely are security and optimization patches provided by the maintainers? I favor tools that demonstrate stability because with stability my software can be developed smoothly, and what is smooth will easily become fast.

### Maintainability 

Creating with code carries with the burden of maintenance. Someone will have to be responsible for ensuring that the software continues to perform and can be updated otherwise the value created will dissipate with age. I value how maintainable my software will be and favor choices that are tried and true and have clear and tested paradigms for maintenance. If I can maintain my system unincumbered, I can focus on improving my codebase quickly and get back to the important task of quickly iterating on new concepts and features.

### Extensibility



### Conclusion

Code is fun - Ruby happy - Matz, restrained, frustrated, ergonomics 